"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { resolve } = require('path');
const makeDir = require('make-dir');
const pMap = require('p-map');
const { getFlags } = require('./feature_flags');
const { createManifest } = require('./manifest');
const { getFunctionsFromPaths } = require('./runtimes');
const { getPluginsModulesPath } = require('./runtimes/node/utils/plugin_modules_path');
const { ARCHIVE_FORMAT_NONE, ARCHIVE_FORMAT_ZIP } = require('./utils/consts');
const { listFunctionsDirectories, resolveFunctionsDirectories } = require('./utils/fs');
const { removeFalsy } = require('./utils/remove_falsy');
const DEFAULT_PARALLEL_LIMIT = 5;
const validateArchiveFormat = (archiveFormat) => {
    if (![ARCHIVE_FORMAT_NONE, ARCHIVE_FORMAT_ZIP].includes(archiveFormat)) {
        throw new Error(`Invalid archive format: ${archiveFormat}`);
    }
};
// Takes the result of zipping a function and formats it for output.
const formatZipResult = (result) => {
    const { bundler, bundlerErrors, bundlerWarnings, config = {}, inputs, mainFile, name, nativeNodeModules, nodeModulesWithDynamicImports, path, runtime, } = result;
    return removeFalsy({
        bundler,
        bundlerErrors,
        bundlerWarnings,
        config,
        inputs,
        mainFile,
        name,
        nativeNodeModules,
        nodeModulesWithDynamicImports,
        path,
        runtime: runtime.name,
    });
};
// Zip `srcFolder/*` (Node.js or Go files) to `destFolder/*.zip` so it can be
// used by AWS Lambda
const zipFunctions = function (relativeSrcFolders, destFolder, { archiveFormat = ARCHIVE_FORMAT_ZIP, basePath, config = {}, featureFlags: inputFeatureFlags, manifest, parallelLimit = DEFAULT_PARALLEL_LIMIT, repositoryRoot = basePath, } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        validateArchiveFormat(archiveFormat);
        const featureFlags = getFlags(inputFeatureFlags);
        const srcFolders = resolveFunctionsDirectories(relativeSrcFolders);
        const [paths] = yield Promise.all([listFunctionsDirectories(srcFolders), makeDir(destFolder)]);
        const [functions, pluginsModulesPath] = yield Promise.all([
            getFunctionsFromPaths(paths, { config, dedupe: true, featureFlags }),
            // All function directories should be part of the same project root, so we
            // can get away with computing the plugins modules path from any of the
            // source directories.
            getPluginsModulesPath(srcFolders[0]),
        ]);
        const results = yield pMap(functions.values(), (func) => __awaiter(this, void 0, void 0, function* () {
            const zipResult = yield func.runtime.zipFunction({
                archiveFormat,
                basePath,
                config: func.config,
                destFolder,
                extension: func.extension,
                filename: func.filename,
                mainFile: func.mainFile,
                name: func.name,
                pluginsModulesPath,
                repositoryRoot,
                runtime: func.runtime,
                srcDir: func.srcDir,
                srcPath: func.srcPath,
                stat: func.stat,
                featureFlags,
            });
            return Object.assign(Object.assign({}, zipResult), { mainFile: func.mainFile, name: func.name, runtime: func.runtime });
        }), {
            concurrency: parallelLimit,
        });
        const formattedResults = results.filter(Boolean).map(formatZipResult);
        if (manifest !== undefined) {
            yield createManifest({ functions: formattedResults, path: resolve(manifest) });
        }
        return formattedResults;
    });
};
const zipFunction = function (relativeSrcPath, destFolder, { archiveFormat = ARCHIVE_FORMAT_ZIP, basePath, config: inputConfig = {}, featureFlags: inputFeatureFlags, pluginsModulesPath: defaultModulesPath, repositoryRoot = basePath, } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        validateArchiveFormat(archiveFormat);
        const featureFlags = getFlags(inputFeatureFlags);
        const srcPath = resolve(relativeSrcPath);
        const functions = yield getFunctionsFromPaths([srcPath], { config: inputConfig, dedupe: true, featureFlags });
        if (functions.size === 0) {
            return;
        }
        const { config, extension, filename, mainFile, name, runtime, srcDir, stat } = functions.values().next().value;
        const pluginsModulesPath = defaultModulesPath === undefined ? yield getPluginsModulesPath(srcPath) : defaultModulesPath;
        yield makeDir(destFolder);
        const zipResult = yield runtime.zipFunction({
            archiveFormat,
            basePath,
            config,
            destFolder,
            extension,
            featureFlags,
            filename,
            mainFile,
            pluginsModulesPath,
            repositoryRoot,
            runtime,
            srcDir,
            srcPath,
            stat,
        });
        return formatZipResult(Object.assign(Object.assign({}, zipResult), { mainFile, name, runtime }));
    });
};
module.exports = { zipFunction, zipFunctions };
//# sourceMappingURL=zip.js.map