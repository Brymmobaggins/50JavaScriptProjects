#!/usr/bin/env node
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const { exit } = require('process');
const yargs = require('yargs');
const zipIt = require('./main');
const { ARCHIVE_FORMAT_NONE, ARCHIVE_FORMAT_ZIP } = require('./utils/consts');
// CLI entry point
const runCli = function () {
    return __awaiter(this, void 0, void 0, function* () {
        const _a = parseArgs(), { destFolder, srcFolder } = _a, options = __rest(_a, ["destFolder", "srcFolder"]);
        try {
            const zipped = yield zipIt.zipFunctions(srcFolder, destFolder, options);
            console.log(JSON.stringify(zipped, null, 2));
        }
        catch (error) {
            console.error(error.toString());
            exit(1);
        }
    });
};
const parseArgs = function () {
    return yargs.command('* <srcFolder> <destFolder>').options(OPTIONS).usage(USAGE).strict().parse();
};
const OPTIONS = {
    'archive-format': {
        string: true,
        choices: [ARCHIVE_FORMAT_NONE, ARCHIVE_FORMAT_ZIP],
        default: ARCHIVE_FORMAT_ZIP,
        describe: 'Format of the archive created for each function',
    },
    config: {
        default: {},
        describe: 'An object matching glob-like expressions to objects containing configuration properties. Whenever a function name matches one of the expressions, it inherits the configuration properties',
    },
    manifest: {
        string: true,
        describe: 'If a manifest file is to be created, specifies its path',
    },
    'parallel-limit': {
        number: true,
        describe: 'Maximum number of Functions to bundle at the same time',
    },
};
const USAGE = `$0 [OPTIONS...] FUNCTIONS_DIRECTORY OUTPUT_DIRECTORY

Zip all function files inside FUNCTIONS_DIRECTORY so that they can be uploaded
to AWS Lambda.`;
runCli();
//# sourceMappingURL=bin.js.map