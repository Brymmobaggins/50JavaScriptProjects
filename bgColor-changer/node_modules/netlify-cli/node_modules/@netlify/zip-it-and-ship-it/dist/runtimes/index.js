"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { extname, basename } = require('path');
const { getConfigForFunction } = require('../config');
const goRuntime = require('./go');
const jsRuntime = require('./node');
const rustRuntime = require('./rust');
/**
 * Finds functions for a list of paths using a specific runtime. The return
 * value is an object containing an array of the functions found (`functions`)
 * and an array with the paths that haven't been recognized by the runtime
 * (`remainingPaths`).
 *
 * @param   {Boolean} dedupe
 * @param   {Object} fsCache
 * @param   {Array<String>} paths
 * @param   {Object} runtime
 * @returns {Promise<Object>}
 */
const findFunctionsInRuntime = function ({ dedupe = false, featureFlags, fsCache, paths, runtime }) {
    return __awaiter(this, void 0, void 0, function* () {
        const functions = yield runtime.findFunctionsInPaths({ featureFlags, fsCache, paths });
        // If `dedupe` is true, we use the function name (`filename`) as the map key,
        // so that `function-1.js` will overwrite `function-1.go`. Otherwise, we use
        // `srcPath`, so that both functions are returned.
        const key = dedupe ? 'name' : 'srcPath';
        // Augmenting the function objects with additional information.
        const augmentedFunctions = functions.map((func) => [
            func[key],
            Object.assign(Object.assign({}, func), { extension: extname(func.mainFile), filename: basename(func.srcPath), runtime }),
        ]);
        const usedPaths = new Set(augmentedFunctions.map(([path]) => path));
        const remainingPaths = paths.filter((path) => !usedPaths.has(path));
        return { functions: augmentedFunctions, remainingPaths };
    });
};
/**
 * Gets a list of functions found in a list of paths.
 *
 * @param   {Object} config
 * @param   {Boolean} dedupe
 * @param   {String} path
 * @returns {Promise<Map>}
 */
const getFunctionsFromPaths = (paths, { config, dedupe = false, featureFlags } = {}) => __awaiter(void 0, void 0, void 0, function* () {
    // An object to cache filesystem operations. This allows different functions
    // to perform IO operations on the same file (i.e. getting its stats or its
    // contents) without duplicating work.
    const fsCache = {};
    // The order of this array determines the priority of the runtimes. If a path
    // is used by the first time, it won't be made available to the subsequent
    // runtimes.
    const runtimes = [jsRuntime, goRuntime, rustRuntime];
    // We cycle through the ordered array of runtimes, passing each one of them
    // through `findFunctionsInRuntime`. For each iteration, we collect all the
    // functions found plus the list of paths that still need to be evaluated,
    // using them as the input for the next iteration until the last runtime.
    const { functions } = yield runtimes.reduce((aggregate, runtime) => __awaiter(void 0, void 0, void 0, function* () {
        const { functions: aggregateFunctions, remainingPaths: aggregatePaths } = yield aggregate;
        const { functions: runtimeFunctions, remainingPaths: runtimePaths } = yield findFunctionsInRuntime({
            dedupe,
            featureFlags,
            fsCache,
            paths: aggregatePaths,
            runtime,
        });
        return {
            functions: [...aggregateFunctions, ...runtimeFunctions],
            remainingPaths: runtimePaths,
        };
    }), { functions: [], remainingPaths: paths });
    const functionsWithConfig = functions.map(([name, func]) => [
        name,
        Object.assign(Object.assign({}, func), { config: getConfigForFunction({ config, func }) }),
    ]);
    return new Map(functionsWithConfig);
});
module.exports = {
    getFunctionsFromPaths,
};
//# sourceMappingURL=index.js.map