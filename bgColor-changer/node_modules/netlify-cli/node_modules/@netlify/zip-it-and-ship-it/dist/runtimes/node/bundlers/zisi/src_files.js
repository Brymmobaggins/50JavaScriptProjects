"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { dirname, basename, normalize } = require('path');
const { not: notJunk } = require('junk');
const precinct = require('precinct');
const { filterExcludedPaths, getPathsOfIncludedFiles } = require('../../utils/included_files');
const { getPackageJson } = require('../../utils/package_json');
const { getNewCache } = require('../../utils/traversal_cache');
const { listImports } = require('./list_imports');
const { resolvePathPreserveSymlinks } = require('./resolve');
const { getDependencyPathsForDependency } = require('./traverse');
const { getTreeFiles } = require('./tree_files');
const { shouldTreeShake } = require('./tree_shake');
// Retrieve the paths to the Node.js files to zip.
// We only include the files actually needed by the function because AWS Lambda
// has a size limit for the zipped file. It also makes cold starts faster.
const getSrcFiles = function ({ config, featureFlags, mainFile, name, pluginsModulesPath, srcDir, srcPath, stat, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const { includedFiles = [], includedFilesBasePath } = config;
        const { exclude: excludedPaths, paths: includedFilePaths } = yield getPathsOfIncludedFiles(includedFiles, includedFilesBasePath);
        const [treeFiles, depFiles] = yield Promise.all([
            getTreeFiles(srcPath, stat),
            getDependencies({ featureFlags, functionName: name, mainFile, pluginsModulesPath, srcDir }),
        ]);
        const files = [...treeFiles, ...depFiles].map(normalize);
        const uniqueFiles = [...new Set(files)];
        // We sort so that the archive's checksum is deterministic.
        // Mutating is fine since `Array.filter()` returns a shallow copy
        const filteredFiles = uniqueFiles.filter(isNotJunk).sort();
        const includedPaths = filterExcludedPaths([...filteredFiles, ...includedFilePaths], excludedPaths);
        return includedPaths;
    });
};
// Remove temporary files like *~, *.swp, etc.
const isNotJunk = function (file) {
    return notJunk(basename(file));
};
// Retrieve all the files recursively required by a Node.js file
const getDependencies = function ({ featureFlags, functionName, mainFile, pluginsModulesPath, srcDir }) {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = yield getPackageJson(srcDir);
        const state = getNewCache();
        try {
            return yield getFileDependencies({
                featureFlags,
                functionName,
                path: mainFile,
                packageJson,
                pluginsModulesPath,
                state,
            });
        }
        catch (error) {
            error.message = `In file "${mainFile}"\n${error.message}`;
            throw error;
        }
    });
};
const getFileDependencies = function ({ featureFlags, functionName, path, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    return __awaiter(this, void 0, void 0, function* () {
        if (state.localFiles.has(path)) {
            return [];
        }
        state.localFiles.add(path);
        const basedir = dirname(path);
        const dependencies = featureFlags.parseWithEsbuild
            ? yield listImports({ functionName, path })
            : precinct.paperwork(path, { includeCore: false });
        const depsPaths = yield Promise.all(dependencies.filter(Boolean).map((dependency) => getImportDependencies({
            dependency,
            basedir,
            featureFlags,
            functionName,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext,
        })));
        // TODO: switch to Array.flat() once we drop support for Node.js < 11.0.0
        // eslint-disable-next-line unicorn/prefer-spread
        return [].concat(...depsPaths);
    });
};
const getImportDependencies = function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    const shouldTreeShakeNext = treeShakeNext || isNextOnNetlify(dependency);
    if (shouldTreeShake(dependency, shouldTreeShakeNext)) {
        return getTreeShakedDependencies({
            dependency,
            basedir,
            featureFlags,
            functionName,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext: shouldTreeShakeNext,
        });
    }
    return getDependencyPathsForDependency({ dependency, basedir, state, packageJson, pluginsModulesPath });
};
const isNextOnNetlify = function (dependency) {
    return basename(dependency, '.js') === 'renderNextPage';
};
// When a file requires another one, we apply the top-level logic recursively
const getTreeShakedDependencies = function ({ dependency, basedir, featureFlags, functionName, packageJson, pluginsModulesPath, state, treeShakeNext, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const path = yield resolvePathPreserveSymlinks(dependency, [basedir, pluginsModulesPath].filter(Boolean));
        const depsPath = yield getFileDependencies({
            featureFlags,
            functionName,
            path,
            packageJson,
            pluginsModulesPath,
            state,
            treeShakeNext,
        });
        return [path, ...depsPath];
    });
};
module.exports = {
    getSrcFiles,
};
//# sourceMappingURL=src_files.js.map