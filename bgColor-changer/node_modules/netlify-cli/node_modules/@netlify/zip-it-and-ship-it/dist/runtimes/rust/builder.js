"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { readFile } = require('fs');
const { basename, join } = require('path');
const { promisify } = require('util');
const pReadFile = promisify(readFile);
const makeDir = require('make-dir');
const tmp = require('tmp-promise');
const toml = require('toml');
const { RUNTIME_RUST } = require('../../utils/consts');
const { lstat } = require('../../utils/fs');
const { runCommand } = require('../../utils/shell');
const { BUILD_TARGET, MANIFEST_NAME } = require('./constants');
const build = ({ config, name, srcDir }) => __awaiter(void 0, void 0, void 0, function* () {
    const functionName = basename(srcDir);
    try {
        yield installToolchainOnce();
    }
    catch (error) {
        error.customErrorInfo = { type: 'functionsBundling', location: { functionName, runtime: RUNTIME_RUST } };
        throw error;
    }
    const targetDirectory = yield getTargetDirectory({ config, name });
    yield cargoBuild({ functionName, srcDir, targetDirectory });
    // By default, the binary will have the same name as the crate and there's no
    // way to override it (https://github.com/rust-lang/cargo/issues/1706). We
    // must extract the crate name from the manifest and use it to form the path
    // to the binary.
    const manifest = yield pReadFile(join(srcDir, MANIFEST_NAME));
    const { package: { name: packageName }, } = toml.parse(manifest);
    const binaryPath = join(targetDirectory, BUILD_TARGET, 'release', packageName);
    const stat = yield lstat(binaryPath);
    return {
        path: binaryPath,
        stat,
    };
});
const cargoBuild = ({ functionName, srcDir, targetDirectory }) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield runCommand('cargo', ['build', '--target', BUILD_TARGET, '--release'], {
            cwd: srcDir,
            env: {
                CARGO_TARGET_DIR: targetDirectory,
            },
        });
    }
    catch (error) {
        const hasToolchain = yield checkRustToolchain();
        if (hasToolchain) {
            console.error(`Could not compile Rust function ${functionName}:\n`);
        }
        else {
            error.message =
                'There is no Rust toolchain installed. Visit https://ntl.fyi/missing-rust-toolchain for more information.';
        }
        error.customErrorInfo = { type: 'functionsBundling', location: { functionName, runtime: RUNTIME_RUST } };
        throw error;
    }
});
const checkRustToolchain = () => __awaiter(void 0, void 0, void 0, function* () {
    try {
        yield runCommand('cargo', ['-V']);
        return true;
    }
    catch (_) {
        return false;
    }
});
// Returns the path of the Cargo target directory.
const getTargetDirectory = ({ config, name }) => __awaiter(void 0, void 0, void 0, function* () {
    const { rustTargetDirectory } = config;
    // If the config includes a `rustTargetDirectory` path, we'll use that.
    if (rustTargetDirectory) {
        // We replace the [name] placeholder with the name of the function.
        const path = rustTargetDirectory.replace(/\[name]/g, name);
        yield makeDir(path);
        return path;
    }
    // If the directory hasn't been configured, we'll use a temporary directory.
    const { path } = yield tmp.dir();
    return path;
});
let toolchainInstallation;
// Sets the default toolchain and installs the build target defined in
// `BUILD_TARGET`. The Promise is saved to `toolchainInstallation`, so
// that we run the command just once for multiple Rust functions.
const installToolchain = () => __awaiter(void 0, void 0, void 0, function* () {
    yield runCommand('rustup', ['default', 'stable']);
    yield runCommand('rustup', ['target', 'add', BUILD_TARGET]);
});
const installToolchainOnce = () => {
    if (toolchainInstallation === undefined) {
        toolchainInstallation = installToolchain();
    }
    return toolchainInstallation;
};
module.exports = { build };
//# sourceMappingURL=builder.js.map