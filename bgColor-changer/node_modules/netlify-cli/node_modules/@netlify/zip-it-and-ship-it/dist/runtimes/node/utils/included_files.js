"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { normalize, resolve } = require('path');
const { promisify } = require('util');
const glob = require('glob');
const minimatch = require('minimatch');
const pGlob = promisify(glob);
// Returns the subset of `paths` that don't match any of the glob expressions
// from `exclude`.
const filterExcludedPaths = (paths, exclude = []) => {
    if (exclude.length === 0) {
        return paths;
    }
    const excludedPaths = paths.filter((path) => !exclude.some((pattern) => minimatch(path, pattern)));
    return excludedPaths;
};
const getPathsOfIncludedFiles = (includedFiles, basePath) => __awaiter(void 0, void 0, void 0, function* () {
    // Some of the globs in `includedFiles` might be exclusion patterns, which
    // means paths that should NOT be included in the bundle. We need to treat
    // these differently, so we iterate on the array and put those paths in a
    // `exclude` array and the rest of the paths in an `include` array.
    const { include, exclude } = includedFiles.reduce((acc, path) => {
        if (path.startsWith('!')) {
            const excludePath = resolve(basePath, path.slice(1));
            return Object.assign(Object.assign({}, acc), { exclude: [...acc.exclude, excludePath] });
        }
        return Object.assign(Object.assign({}, acc), { include: [...acc.include, path] });
    }, { include: [], exclude: [] });
    const pathGroups = yield Promise.all(include.map((expression) => pGlob(expression, { absolute: true, cwd: basePath, ignore: exclude, nodir: true })));
    // `pathGroups` is an array containing the paths for each expression in the
    // `include` array. We flatten it into a single dimension.
    const paths = pathGroups.flat();
    const normalizedPaths = paths.map(normalize);
    return { exclude, paths: [...new Set(normalizedPaths)] };
});
module.exports = { filterExcludedPaths, getPathsOfIncludedFiles };
//# sourceMappingURL=included_files.js.map