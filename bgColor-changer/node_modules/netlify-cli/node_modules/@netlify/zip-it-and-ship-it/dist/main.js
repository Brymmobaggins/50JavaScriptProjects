"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const { extname } = require('path');
require('./utils/polyfills');
const { getFlags } = require('./feature_flags');
const { getFunctionsFromPaths } = require('./runtimes');
const { getPluginsModulesPath } = require('./runtimes/node/utils/plugin_modules_path');
const { listFunctionsDirectories, resolveFunctionsDirectories } = require('./utils/fs');
const { zipFunction, zipFunctions } = require('./zip');
// List all Netlify Functions main entry files for a specific directory
const listFunctions = function (relativeSrcFolders, { featureFlags: inputFeatureFlags } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const featureFlags = getFlags(inputFeatureFlags);
        const srcFolders = resolveFunctionsDirectories(relativeSrcFolders);
        const paths = yield listFunctionsDirectories(srcFolders);
        const functions = yield getFunctionsFromPaths(paths, { featureFlags });
        const listedFunctions = [...functions.values()].map(getListedFunction);
        return listedFunctions;
    });
};
// List all Netlify Functions files for a specific directory
const listFunctionsFiles = function (relativeSrcFolders, { basePath, config, featureFlags: inputFeatureFlags } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        const featureFlags = getFlags(inputFeatureFlags);
        const srcFolders = resolveFunctionsDirectories(relativeSrcFolders);
        const paths = yield listFunctionsDirectories(srcFolders);
        const [functions, pluginsModulesPath] = yield Promise.all([
            getFunctionsFromPaths(paths, { config, featureFlags }),
            getPluginsModulesPath(srcFolders[0]),
        ]);
        const listedFunctionsFiles = yield Promise.all([...functions.values()].map((func) => getListedFunctionFiles(func, { basePath, featureFlags, pluginsModulesPath })));
        // TODO: switch to Array.flat() once we drop support for Node.js < 11.0.0
        // eslint-disable-next-line unicorn/prefer-spread
        return [].concat(...listedFunctionsFiles);
    });
};
const getListedFunction = function ({ runtime, name, mainFile, extension }) {
    return { name, mainFile, runtime: runtime.name, extension };
};
const getListedFunctionFiles = function ({ config, runtime, name, stat, mainFile, extension, srcPath, srcDir }, { basePath, featureFlags, pluginsModulesPath }) {
    return __awaiter(this, void 0, void 0, function* () {
        const srcFiles = yield getSrcFiles({
            basePath,
            featureFlags,
            runtime,
            stat,
            mainFile,
            extension,
            srcPath,
            srcDir,
            pluginsModulesPath,
            config,
        });
        return srcFiles.map((srcFile) => ({ srcFile, name, mainFile, runtime: runtime.name, extension: extname(srcFile) }));
    });
};
const getSrcFiles = function ({ basePath, bundler, config, featureFlags, runtime, stat, mainFile, extension, srcPath, srcDir, pluginsModulesPath, }) {
    const { getSrcFiles: getRuntimeSrcFiles } = runtime;
    if (extension === '.zip' || typeof getRuntimeSrcFiles !== 'function') {
        return [srcPath];
    }
    return getRuntimeSrcFiles({
        basePath,
        bundler,
        config,
        extension,
        featureFlags,
        srcPath,
        mainFile,
        srcDir,
        stat,
        pluginsModulesPath,
    });
};
module.exports = { zipFunctions, zipFunction, listFunctions, listFunctionsFiles };
//# sourceMappingURL=main.js.map